{"version":3,"sources":["../../../server/noAuthEndpoint/webhook.js"],"names":["init","receivedMessage","event","dh","senderID","sender","id","recipientID","recipient","timeOfMessage","timestamp","message","logger","info","JSON","stringify","Promise","all","getQuestionFlow","getUserProgress","getUserResponse","getUserProfile","getAccessToken","then","questionFlow","userProgress","userResponse","userProfile","accessToken","userID","postback","referral","isProfileFetched","page_access_token","get","constant","PAGE_ACCESS_TOKEN_KEY","fbrequest","uri","GRAPH_BASE_URL","qs","profile","update","catch","err","error","expectRespType","stopAtQid","nextQid","confirmationQid","responseHandlerMap","isGoingBack","currentQuestion","findQuestionWithQid","endFire","name","trigger","payload","currentConfirmationId","type","nextExpectRespType","app","WEBHOOK_PATH","req","res","query","send","post","data","body","object","entry","forEach","pageEntry","messaging","messagingEvent","Object","assign","fbtrEvents","LEADGENBOT_MSG_RECEIVED","sendStatus"],"mappings":"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","file":"webhook.js","sourcesContent":["import logger from 'common/logger';\nimport constant from 'common/constant';\nimport fbrequest from 'common/fbrequest';\nimport {sendQuestion} from 'server/helper/MessengerHelper';\nimport {responseHandlerMap} from 'server/handler/responseHandlers';\nimport {fbtrEvents, fbtr} from 'common/fbtr';\nimport { cfbtr } from 'common/cfbtr';\n\nfunction receivedMessage(event, dh) {\n  let senderID = event.sender.id;\n  let recipientID = event.recipient.id;\n  let timeOfMessage = event.timestamp;\n  let message = event.message;\n\n  logger.info(\n    `Received message for user ${senderID} and page ${recipientID} at ${timeOfMessage} ` +\n    `with message: ${JSON.stringify(message)}`\n  );\n\n  Promise.all([\n    dh.getQuestionFlow(),\n    dh.getUserProgress(senderID),\n    dh.getUserResponse(senderID),\n    dh.getUserProfile(senderID),\n    dh.getAccessToken(),\n  ])\n  .then(([questionFlow, userProgress, userResponse, userProfile, accessToken]) => {\n    logger.info(`user ${userProgress.userID} at progress ${JSON.stringify(userProgress.userProgress)}`);\n    if (event.postback && event.postback.referral) {\n      // TODO: handle user info and referral info here\n    }\n\n    if (!userProfile.isProfileFetched()) {\n      // user profile not found in data store, fetching from graph api\n      var page_access_token = accessToken.get(constant.PAGE_ACCESS_TOKEN_KEY);\n      logger.info(`Fetching user profile for ${userProfile.userID}`);\n      fbrequest.get({\n        uri: `${constant.GRAPH_BASE_URL}/${userProfile.userID}`,\n        qs: {\n          'access_token': page_access_token,\n        },\n      })\n      .then((profile) => {\n        logger.info(`user profile fetched ${JSON.stringify(profile)}`);\n        userProfile.update(profile);\n      })\n      .catch((err) => {\n        logger.error(`Profile fetch failed with ${err}`);\n      });\n    }\n\n    let {expectRespType, stopAtQid, nextQid, confirmationQid} = userProgress.userProgress;\n    expectRespType = expectRespType || 'genesis';\n    nextQid = nextQid || 0;\n    responseHandlerMap[expectRespType](message, event, questionFlow, userProgress, userResponse)\n      .then(({nextQid, isGoingBack}) => {\n        //before going to next question, check if this question requires event to be fired\n        let currentQuestion = questionFlow.findQuestionWithQid(stopAtQid);\n\n        if (currentQuestion.event?currentQuestion.event.endFire:false) {\n          logger.info(`Trigger reply custom event: ${currentQuestion.event.name}.`);\n          cfbtr(currentQuestion.event.name, currentQuestion, senderID, {\n            trigger:'END',\n            payload:JSON.stringify(message)\n          });\n        }\n\n        let currentConfirmationId = null;\n\n        if (currentQuestion.type == 'confirmation' && isGoingBack) {\n          currentConfirmationId = stopAtQid;\n        } else if (confirmationQid) {\n          nextQid = confirmationQid;\n        }\n\n        // we can hanlde this response, go to next question\n        return sendQuestion(userProfile, nextQid, questionFlow, userResponse)\n          .then(([stopAtQid, nextExpectRespType]) => {\n            userProgress.update({\n              expectRespType: nextExpectRespType,\n              nextQid: nextQid,\n              stopAtQid: stopAtQid,\n              confirmationQid: currentConfirmationId,\n            });\n          });\n      })\n      .catch((err) => {\n        logger.error(`Oops, can not handle user response because ${err} ${JSON.stringify(err)}`);\n        logger.info('fall back to re-send last question.');\n        // can not handle this response, repeat last question\n        sendQuestion(userProfile, nextQid, questionFlow, userResponse)\n          .then(([stopAtQid, nextExpectRespType]) => {\n            userProgress.update({\n              expectRespType: nextExpectRespType,\n              nextQid: nextQid,\n              stopAtQid: stopAtQid,\n            });\n          });\n      });\n  });\n}\n\nexport function init(app, dh) {\n  app.get(constant.WEBHOOK_PATH, (req, res) => {\n    if (req.query['hub.verify_token'] === 'TEMPLATE_BOT') {\n      res.send(req.query['hub.challenge']);\n    } else {\n      res.send('Error, wrong validation token');\n    }\n  });\n\n  app.post(constant.WEBHOOK_PATH, (req, res) => {\n    let data = req.body;\n    if (data.object == 'page') {\n      data.entry.forEach((pageEntry) => {\n        pageEntry.messaging.forEach((messagingEvent) => {\n          if (messagingEvent.message) {\n            receivedMessage(messagingEvent, dh);\n          } else if (messagingEvent.postback) {\n            receivedMessage(Object.assign(messagingEvent, {\n              message: messagingEvent.postback.payload,\n            }), dh);\n          } else {\n            logger.info(`Webhook received unsupported messageEvent: ${JSON.stringify(messagingEvent)}`);\n          }\n          fbtr(fbtrEvents.LEADGENBOT_MSG_RECEIVED, messagingEvent.sender.id);\n        });\n      });\n      res.sendStatus(200);\n    }\n  });\n}\n"]}